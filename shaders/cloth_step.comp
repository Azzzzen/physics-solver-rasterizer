#version 430 core

layout(local_size_x = 128) in;

layout(std430, binding = 0) readonly buffer PosInBuffer {
    vec4 posIn[];
};
layout(std430, binding = 1) readonly buffer VelInBuffer {
    vec4 velIn[];
};
layout(std430, binding = 2) writeonly buffer PosOutBuffer {
    vec4 posOut[];
};
layout(std430, binding = 3) writeonly buffer VelOutBuffer {
    vec4 velOut[];
};
layout(std430, binding = 4) readonly buffer FixedBuffer {
    int fixedFlags[];
};

uniform int uRows;
uniform int uCols;
uniform int uNumParticles;
uniform float uDt;
uniform float uSpacing;
uniform float uMass;
uniform float uStiffness;
uniform float uDamping;
uniform float uSpringDamping;
uniform float uMaxSpeed;
uniform float uGroundY;
uniform vec3 uGravity;
uniform vec3 uWind;
uniform int uDraggedIndex;
uniform vec3 uDragTarget;

float springRestLength(int dr, int dc) {
    int adr = abs(dr);
    int adc = abs(dc);
    if ((adr == 1 && adc == 0) || (adr == 0 && adc == 1)) {
        return uSpacing;
    }
    if (adr == 1 && adc == 1) {
        return uSpacing * 1.41421356237;
    }
    return uSpacing * 2.0;
}

void addImplicitSpring(
    inout mat3 A,
    inout vec3 rhs,
    int r,
    int c,
    int nr,
    int nc,
    vec3 p,
    vec3 v) {
    if (nr < 0 || nr >= uRows || nc < 0 || nc >= uCols) {
        return;
    }

    int nidx = nr * uCols + nc;
    vec3 np = posIn[nidx].xyz;
    vec3 nv = velIn[nidx].xyz;

    vec3 delta = p - np;
    float len = length(delta);
    if (len <= 1e-6) {
        return;
    }

    vec3 dir = delta / len;
    float rest = springRestLength(nr - r, nc - c);
    float stretch = len - rest;

    vec3 fPos = (-uStiffness * stretch) * dir;
    rhs += uDt * fPos;

    float coupling = uDt * uDt * uStiffness + uDt * uSpringDamping;
    mat3 P = outerProduct(dir, dir);
    A += coupling * P;
    rhs += coupling * (P * nv);
}

void main() {
    uint gid = gl_GlobalInvocationID.x;
    if (gid >= uint(uNumParticles)) {
        return;
    }

    int idx = int(gid);
    vec3 p = posIn[idx].xyz;
    vec3 v = velIn[idx].xyz;

    if (fixedFlags[idx] != 0) {
        posOut[idx] = vec4(p, 0.0);
        velOut[idx] = vec4(0.0);
        return;
    }

    if (idx == uDraggedIndex) {
        posOut[idx] = vec4(uDragTarget, 0.0);
        velOut[idx] = vec4(0.0);
        return;
    }

    int r = idx / uCols;
    int c = idx - r * uCols;

    float diag = uMass + uDt * uDamping;
    mat3 A = mat3(diag, 0.0, 0.0, 0.0, diag, 0.0, 0.0, 0.0, diag);
    vec3 rhs = uMass * v + uDt * (uMass * uGravity + uWind);

    addImplicitSpring(A, rhs, r, c, r, c - 1, p, v);
    addImplicitSpring(A, rhs, r, c, r, c + 1, p, v);
    addImplicitSpring(A, rhs, r, c, r - 1, c, p, v);
    addImplicitSpring(A, rhs, r, c, r + 1, c, p, v);

    addImplicitSpring(A, rhs, r, c, r - 1, c - 1, p, v);
    addImplicitSpring(A, rhs, r, c, r - 1, c + 1, p, v);
    addImplicitSpring(A, rhs, r, c, r + 1, c - 1, p, v);
    addImplicitSpring(A, rhs, r, c, r + 1, c + 1, p, v);

    addImplicitSpring(A, rhs, r, c, r, c - 2, p, v);
    addImplicitSpring(A, rhs, r, c, r, c + 2, p, v);
    addImplicitSpring(A, rhs, r, c, r - 2, c, p, v);
    addImplicitSpring(A, rhs, r, c, r + 2, c, p, v);

    vec3 vNew = inverse(A) * rhs;

    float speed = length(vNew);
    if (speed > uMaxSpeed) {
        vNew *= uMaxSpeed / speed;
    }

    vec3 pNew = p + uDt * vNew;

    if (pNew.y < uGroundY) {
        pNew.y = uGroundY;
        vNew.y *= -0.15;
    }

    posOut[idx] = vec4(pNew, 0.0);
    velOut[idx] = vec4(vNew, 0.0);
}
